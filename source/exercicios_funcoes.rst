#. Fa√ßa uma fun√ß√£o que determina se um n√∫mero √© par ou √≠mpar. Use o ``%`` para
   determinar o resto de uma divis√£o. Por exemplo: ``3 % 2 = 1`` e ``4 % 2 = 0``

#. Fa√ßa uma fun√ß√£o que calcule a √°rea de um c√≠rculo. Insira o raio como
   argumento.

   **Dica:** fa√ßa a importa√ß√£o de ``math`` e use :math:`\pi` de l√°.

   .. math::

            A = \pi R^2

#. Crie uma fun√ß√£o que receba um valor de temperatura em Fahrenheit e transforme
   em Celsius.

   Relembrar √© viver:

        .. math::

                \frac{C}{5} = \frac{F - 32}{9}

#. Crie uma fun√ß√£o que receba 3 valores e calcula as ra√≠zes da f√≥rmula de
   Bh√°skara.

   .. math::

        x = \frac{-b \pm \sqrt{b^2 - 4 \cdot a \cdot c}}{2 \cdot a}

   **Dica:** raiz quadrada √© ``sqrt()``, importando ``math``: ``math.sqrt()``

   Fa√ßa um teste com ``bhaskara(1, -4, -5)`` e o programa deve obter as ra√≠zes:
   (5.0, -1.0)

#. Dada a fun√ß√£o: :math:`y = 5x + 2`, determine os valores de :math:`y` para
   :math:`x` entre -10 a +10, onde :math:`x` √© inteiro

#. Escreva uma fun√ß√£o chamada ``has_duplicates`` que tome uma lista e retorne
   ``True`` se houver algum elemento que apare√ßa mais de uma vez. Ela n√£o deve
   modificar a lista original.

#. Duas palavras s√£o um ‚Äúpar inverso‚Äù se uma for o contr√°rio da outra. Escreva
   uma fun√ß√£o que dado duas palavras, retorne ``True`` caso sejam.

#. Escreva uma fun√ß√£o que imprime todos os n√∫meros primos entre 1 e 50

   **Dica:** um n√∫mero √© primo se ele for divis√≠vel apenas por 1 e ele mesmo,
   use o operador ``%`` (resto da divis√£o) para isso.

#. Duas palavras s√£o anagramas se voc√™ puder soletrar uma rearranjando as letras
   da outra. Escreva uma fun√ß√£o chamada ``is_anagram`` que tome duas strings e
   retorne ``True`` se forem anagramas ou False caso contr√°rio.

#. Escreva uma fun√ß√£o que dado um n√∫mero, calcule o fatorial desse n√∫mero.
   Por exemplo, fatorial de 5:

    .. math::

        5! = 5 \cdot 4 \cdot 3 \cdot 2 \cdot 1 = 120

#. Crie uma fun√ß√£o que aproxima a fun√ß√£o matem√°tica seno, utilizando a seguinte
   equa√ß√£o:

   .. math::

        \sin(x) = \sum_{n=0}^{\infty} \frac{(-1)^n}{(2n+1)!} x^{2n+1}

   Essa e a expans√£o em S√©rie de *Taylor* da fun√ß√£o. Note que esta √© uma s√©rie
   infinita! A sua fun√ß√£o deve truncar a s√©rie em algum momento, ou seja, sua
   fun√ß√£o vai calcular uma aproxima√ß√£o para o seno de um √¢ngulo:

   .. math::

        \sin(x) \approx \sum_{n=0}^{N} \frac{(-1)^n}{(2n+1)!} x^{2n+1}

   Note que, quanto maior o valor de N, melhor √© a aproxima√ß√£o. Mas isso tem um
   custo: maior vai ser o n√∫mero de termos nessa s√©rie e consequentemente, maior
   o tempo de execu√ß√£o desse c√≥digo.

   Uma possibilidade √© estipular previamente uma *precis√£o* a ser atingida pelo
   c√≥digo. Ou seja, definimos o desvio m√°ximo :math:`\epsilon` que nossa
   aproxima√ß√£o tem com rela√ß√£o ao valor exato! Isso √© feito comparando dois termos
   consecutivos da s√©rie: se a diferen√ßa entre eles (em valor absoluto!) for menor
   que :math:`\epsilon`, atingimos a precis√£o desejada.

   Implemente, ent√£o, uma fun√ß√£o que receba como argumentos:

   * :math:`x`: o √¢ngulo (em radianos!!).

   * :math:`N_\mathrm{max}`: o n√∫mero m√°ximo de itera√ß√µes.

   * :math:`\epsilon`: a precis√£o da aproxima√ß√£o.

   e calcule uma aproxima√ß√£o para :math:`\sin(x)` usando duas condi√ß√µes de parada:
   n√∫mero m√°ximo de termos na s√©rie √© :math:`N_\mathrm{max}` **e** precis√§o
   :math:`\epsilon`.

   .. only:: instructors

      Exemplo de solu√ß√£o:

      .. code:: python

         import math

         def seno(x, Nmax = 137, eps = 1e-8):
             n = 0
             diff = 42 * eps
             soma = 0

             while(n <= Nmax and abs(diff) > eps):
                 termo = (-1)**n * x**(2*n + 1) / fatorial(2*n + 1)
                 soma += termo

                 diff = termo
                 n += 1

             return soma


         def fatorial(N):
             fat = 1
             while(N > 1):
                 fat = fat * N
                 N -= 1

             return fat


         for i in range(1, 200):
             alpha = i * math.pi / 180 # converte o angulo pra radiano

             approx = seno(alpha)
             error = abs(approx - math.sin(alpha))

             print(approx, error)



#. Calcule :math:`\pi` usando um m√©todo de Monte Carlo.

   Monte Carlo √© uma classe de m√©todos para resolver problemas usando
   estat√≠stica. Aqui voc√™ vai implementar uma fun√ß√£o usando um desses algoritmos
   para calcular o n√∫mero :math:`\pi`.

   Dado um c√≠rculo de raio :math:`R` dentro de um quadrado de lados :math:`2R`,
   a raz√£o entre a √°rea do c√≠rculo para a √°rea do quadrado √©:

   .. math::

      \frac{A_\bigcirc}{A_\square} = \frac{\pi R^2}{4 R^2} = \frac{\pi}{4}

   Ou seja, se voc√™ escolher aleatoriamente um ponto dentro do quadrado, a
   probabilidade dele cair dentro do c√≠rculo √© de :math:`\pi / 4`. Se voc√™
   escolher :math:`N` pontos aleat√≥rios dentro do quadrado, cerca de
   :math:`N \pi / 4` estar√£o dentro do c√≠rculo.

   Ent√£o, basta escolher pontos aleat√≥rios dentro do quadrado e ver se est√£o
   dentro do c√≠rculo üôÉ.

   Um ponto :math:`(x, y)` est√° dentro do c√≠rculo se
   :math:`x^2 + y^2 \leq R^2`.

   Fa√ßa uma fun√ß√£o que receba como argumento um n√∫mero :math:`N` de pontos
   :math:`(x, y)` (aleat√≥rios) a serem sorteados. Dentro dessa fun√ß√£o, voc√™
   deve fazer um la√ßo que sorteie esses :math:`N` pontos e veja quantos est√£o
   dentro do c√≠rculo. Se :math:`M` pontos ca√≠rem dentro do c√≠rculo, ent√£o a
   probabilidade de um ponto aleat√≥rio estar dentro do c√≠rculo √©
   aproximadamente :math:`M / N`. Ent√£o, podemos estimar :math:`\pi` como:

   .. math::

      \pi \approx \frac{4 M}{N}

   Para sortear um n√∫mero aleat√≥rio entre :math:`a` e :math:`b` utilize a
   fun√ß√£o `uniform(a, b)` do m√≥dulo `random`. Exemplo:


   .. doctest::

      >>> import random
      >>> random.uniform(1, 2) # n√∫mero aleat√≥rio entre 1 e 2
      1.8740445361226983


   .. only:: instructors

      Exemplo de solu√ß√£o:

      .. code:: python

         import random

         def pi(N, R = 1):
             M = 0
             for i in range(N):
                 x, y = random.uniform(-R, R), random.uniform(-R, R)

                 if (x**2 + y**2 < R**2):
                     M += 1

             return 4 * M / N

         print(pi(10000000)) # demora um pouquinho :P

#. D3yver50n resolveu minerar criptomoedas. Ele decidiu minerar *Ethereum* e viu
   que :math:`1\, ETH = $687.86\, USD` e :math:`$1\, USD = R$3.59`. Ele comprou
   o seguinte computador:

   - 5 placas de v√≠deo: GTX1080 TI, cada uma por R$5270,90

   - 1 placa m√£e: ASRock H110 Pro, por R$920

   - 1 fonte: 1000 W, por R$1149,90

   - 1 HD: 1 TB, SATA3, 7200 RPM por R$208,90

   - 2 pentes de mem√≥ria: 4 GB, DDR4, 2400 MHZ, cada um por R$259,90

   - 1 CPU: Intel Core i5-8500 por R$899,90

   E resolveu montar usando uma estante de madeira e dois tijolos, para coolear
   melhor:

   .. figure:: images/cluster.jpg
      :align: center
      :width: 70%

   Essas GPUs conseguem minerar Ethereum a uma taxa de :math:`\approx 27 Mh/s`
   (mega hash / s). Cada bloco minerado d√° uma recompensa de 3 ETH.
   Considere a dificuldade da rede de :math:`3.29 \cdot 10^{15}`,
   o *block time* m√©dio de :math:`15.44\, s`.

   Para calcular quantos d√≥lares por segundo ele vai ganhar com esse computador,
   D3yver50n fez as seguintes contas:

   .. math::

        ETH / s = \mathrm{cluster\_ratio} \frac{recompensa}{\mathrm{block\_time}}

   O cluster_ratio √© calculado como:

   .. math::

      \mathrm{cluster\_ratio} = n_\mathrm{GPU} \frac{\mathrm{GPU\_hashrate}}{\mathrm{network\_hashrate}}

   onde :math:`n_\mathrm{GPU}` √© o n√∫mero de placas de v√≠deo que ele tem.
   O network_hashrate √© calculado como:

   .. math::

      \mathrm{network\_hashrate} = \frac{\mathrm{dificuldade}}{\mathrm{block\_time}}

   a. Calcule quantos ETH por segundo D3yver50n vai ganhar com esse PC.

   b. Calcule quantos d√≥lares por segundo ele vai ganhar.

   c. Calcule quanto ele vai pagar de energia el√©trica por segundo para manter
      esse computador ligado, sabendo que o custo de energia el√©trica √© de
      :math:`0.008 \mathrm{centavos} / kW`.

   d. Ap√≥s um m√™s, quantos ETH ele vai ganhar? Isso equivale a quantos reais?
      Quanto de energia el√©trica ele vai gastar? Deu lucro ou preju√≠zo?

   e. Se ele teve lucro, ap√≥s quanto tempo ele ganha o dinheiro que investiu
      no computador de volta?
